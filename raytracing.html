<!DOCTYPE html>
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-K011FJJQJG"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-K011FJJQJG');
</script>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursive Ray Tracer Implementation</title>
    
    <!-- Google Fonts: JetBrains Mono -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    
    <!-- Linked Stylesheet (for theme and core styling) -->
    <link rel="stylesheet" href="style.css">
</head>

<body>
<div class="wrapper">
    
    <a href="index.html" class="back-link"><i class="fas fa-arrow-left mr-2"></i> Back to Projects</a>

    <header>
        <div class="header-meta">
            <h1>Recursive Ray Tracer (C++)</h1>
            <p>Project: High-Performance Renderer Architecture and Core Ray Tracing Loop</p>
            <div class="meta-tags">
                <span>C++</span>
                <span>Graphics</span>
                <span>Ray Tracing</span>
                <span>Scene Graph</span>
                <span>Architecture</span>
            </div>
        </div>

        <div class="header-bio mt-6">
            <span class="section-label">Overview & Accomplishment</span>
            <p>
                This project involved creating the foundational architecture for a recursive ray tracing renderer in C++. The core accomplishment was implementing a decoupled rendering pipeline by using an abstract renderer base class and a custom Scene Graph. This allowed the system to switch seamlessly between a fast OpenGL rendering preview and the custom Ray Tracing calculation kernel.
            </p>
            <p class="mt-2">
                The technical focus was on calculating the correct camera rays, managing polygon transformations from local to world space, and integrating with a specialized intersection engine to find the nearest hit point, forming the basis for lighting, shadows, and reflections.
            </p>
        </div>
    </header>

    <div class="content-section">

        <div class="flex-section">
            <div class="text-content">
                <h2>Renderer Architecture & System Design</h2>
                <p>
                    I designed the renderer around a strict separation between scene representation and rendering execution. Geometry, materials, and transformations were defined independently of the rendering method, allowing the same scene to be rendered through different pipelines without modification.
                </p>
                <p>
                    This architectural choice reduced coupling, simplified debugging, and ensured the system could scale beyond a single rendering technique. It also enabled rapid iteration on the ray tracing logic without destabilizing scene construction.
                </p>
            </div>
        </div>

        <div class="flex-section reverse">
            <div class="text-content">
                <h2>Hierarchical Transformations & World-Space Accuracy</h2>
                <p>
                    All objects were organized hierarchically, allowing transformations to propagate naturally through the scene. Translation and rotation logic was handled centrally to guarantee consistency across complex object groupings.
                </p>
                <p>
                    A transformation stack accumulated these changes and applied the final composite transform to every vertex and normal before intersection testing. This ensured that visual placement and geometric calculations remained perfectly aligned in world space.
                </p>
            </div>
        </div>

        <div class="flex-section">
            <div class="text-content">
                <h2>Ray Construction & Camera Mathematics</h2>
                <p>
                    The core rendering loop was built from first principles. Each pixel was mapped to a ray originating at the camera and passing through a mathematically defined projection plane based on field of view and aspect ratio.
                </p>
                <ol>
                    <li>Convert pixel coordinates into normalized projection-plane space.</li>
                    <li>Construct and normalize the corresponding world-space ray direction.</li>
                    <li>Query the intersection system to identify the nearest surface hit.</li>
                    <li>Assign pixel color based on material data or background state.</li>
                </ol>
                <p>
                    This approach emphasized correctness and predictability, forming a reliable base for future lighting and recursion.
                </p>
            </div>
        </div>

        <div class="flex-section reverse">
            <div class="text-content">
                <h2>Incremental Validation Strategy</h2>
                <p>
                    Rather than introducing lighting complexity early, I validated the pipeline using minimal shading. This allowed me to isolate issues in ray construction, transformation accuracy, and intersection logic without visual noise.
                </p>
                <p>
                    Once correctness was established, the system was prepared to support shadows, reflections, and recursive ray evaluation without architectural changes.
                </p>
            </div>
        </div>

        <h2>Outcome & Technical Impact</h2>
        <p>
            The final result is a clean, extensible ray tracing foundation with clearly defined responsibilities and mathematically consistent behavior. The architecture supports future feature expansion while maintaining correctness and maintainability.
        </p>
        <p>
            This project demonstrates a problem-solving mindset focused on decomposition, validation of fundamentals, and designing systems that scale in complexity without sacrificing clarity.
        </p>

    </div>

    <footer>
        <div>Last updated 2025</div>
        <div class="footer-links">
            <a href="https://mehtadak.github.io/resume.pdf" target="_blank">Resume ↗</a>
            <a href="https://github.com/mehtadak" target="_blank">GitHub ↗</a>
            <a href="https://linkedin.com/in/mehtadak" target="_blank">LinkedIn ↗</a>
            <a href="mailto:mehtadak@msu.edu">Email ↗</a>
        </div>
    </footer>

</div>
</body>
</html>